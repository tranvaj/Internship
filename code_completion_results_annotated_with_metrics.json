[
    {
        "middle": "cracked = []",
        "fill": "cracked = []",
        "original_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []time_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "generated_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []time_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "correct": true,
        "exact_match": 1,
        "chrf_score": 1.0,
        "bleu_score": 1.2213386697554703e-77,
        "levenshtein": 0
    },
    {
        "middle": "                count = count + 1",
        "fill": "                if sha256_passwd == t[1]:",
        "original_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "generated_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                if sha256_passwd == t[1]:                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.03597122302158282,
        "bleu_score": 0,
        "levenshtein": 22
    },
    {
        "middle": "        if found_passwd != \"\":",
        "fill": "         time_spent = time.time() - time_start",
        "original_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "generated_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n         time_spent = time.time() - time_start            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.0653594771241831,
        "bleu_score": 0,
        "levenshtein": 35
    },
    {
        "middle": "        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))",
        "fill": "    else:",
        "original_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "generated_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n    else:        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.007656967840735149,
        "bleu_score": 0,
        "levenshtein": 78
    },
    {
        "middle": "    if found_passwd != \"\":",
        "fill": "    if found_passwd == \"\":",
        "original_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "generated_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd == \"\":        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.786551755205006,
        "bleu_score": 1.0547686614863434e-154,
        "levenshtein": 1
    },
    {
        "middle": "                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()",
        "fill": "            if sha256_passwd == t[1]:",
        "original_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "generated_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n            if sha256_passwd == t[1]:                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.23814953195274635,
        "bleu_score": 1.2882297539194154e-231,
        "levenshtein": 45
    },
    {
        "middle": "    time_start = time.time()",
        "fill": "    for h in hashes:",
        "original_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "generated_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    for h in hashes:    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.03949447077409172,
        "bleu_score": 0,
        "levenshtein": 19
    },
    {
        "middle": "    for c in cracked:",
        "fill": "    for c in cracked:",
        "original_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "generated_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "correct": true,
        "exact_match": 1,
        "chrf_score": 1.0,
        "bleu_score": 1.0,
        "levenshtein": 0
    },
    {
        "middle": "    found_passwd = \"\"",
        "fill": "    if t[1] == \"A21B0299P\":",
        "original_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "generated_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    if t[1] == \"A21B0299P\":    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.05450500556173534,
        "bleu_score": 0,
        "levenshtein": 21
    },
    {
        "middle": "        continue",
        "fill": "    else:",
        "original_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n        continue\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "generated_code": "#load csv  file with ; as separator\ntuples =  [tuple(line.strip().split(',')) for line in open('password_database.csv')]\ntuples = [tuple for tuple in tuples if tuple[0] == \"A21B0299P\"]\n#print(tuples)\n\npasses = [line for line in open(\"10-million-password-list-top-10000.txt\")]\n#print(passes)\n\n#sha256 load\nfrom hashlib import sha256\nimport string\nimport itertools\nimport time\n\nhashes = [(passwd, sha256(passwd.encode(\"utf-8\")).hexdigest()) for passwd in passes]\ncracked = []\ntime_sum = 0\nfor t in tuples:\n    found_passwd = \"\"\n    count = 0\n    print(\"\\nCracking password for hash: \", t[1])\n    print(\"Trying dictionary attack\")\n    time_start = time.time()\n    for h in hashes:\n        count += 1\n        if h[1] == t[1]:\n            found_passwd = h[0]\n            print(\"Password is: \", h[0].strip())\n            break\n\n    if found_passwd != \"\":\n        print(\"Time taken: \", time.time() - time_start, \" seconds\")\n        cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n        time_sum += time.time() - time_start\n    else:\n    count = 0\n    print(\"Trying brute force...\")\n    characters_to_try = [string.digits, string.ascii_lowercase + string.digits]\n    for characters in characters_to_try:\n        print(\"Trying with characters: \", characters)\n        for length in range(1, 6 + 1):\n            for combo in itertools.product(characters, repeat=length):\n                # Join the tuple to form a string\n                passwd = ''.join(combo) + \"\\n\"\n                sha256_passwd = sha256(passwd.encode(\"utf-8\")).hexdigest()\n                count = count + 1\n                if sha256_passwd == t[1]:\n                    found_passwd = passwd\n                    print(\"Password is: \", passwd.strip())\n                    print(\"Time taken: \", time.time() - time_start, \" seconds\")\n                    cracked.append((t[1], found_passwd.strip(), count, time.time() - time_start))\n                    time_sum += time.time() - time_start\n                    break\n                time_spent = time.time() - time_start\n                if time_sum + time_spent > 60*12:\n                    print(\"Program taking more than 12 minutes, breaking\")\n                    break\n\n            if found_passwd != \"\":\n                break\n        if found_passwd != \"\":\n            break\n\n    if found_passwd == \"\":\n        print(\"Password not found\")\n        cracked.append((t[1], \"not cracked\", count, time.time() - time_start))\n\n\n\noutput_filename = \"cracked_results_A21B0299P.csv\"\nwith open(output_filename, \"w\") as f:\n    for c in cracked:\n        f.write(f\"{c[0]};{c[1]};{c[2]};{c[3]}\\n\")\n\n\n        \n\n\n\n",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.021645021645021734,
        "bleu_score": 0,
        "levenshtein": 12
    },
    {
        "middle": "def bytes2binstr(b, n=None):",
        "fill": "def bytes2binstr(b):",
        "original_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "generated_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b):    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "correct": true,
        "exact_match": 0,
        "chrf_score": 0.6539362962833001,
        "bleu_score": 9.291879812217675e-232,
        "levenshtein": 8
    },
    {
        "middle": "            inc = random.randint(1, RANDOM_INC)",
        "fill": "            seq.append(inc)",
        "original_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "generated_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            seq.append(inc)            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.07245907841908789,
        "bleu_score": 0,
        "levenshtein": 30
    },
    {
        "middle": "            f.write(str(self.q))",
        "fill": "            f.write(','.join(map(str, self.q)))  # Convert each integer to a string",
        "original_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "generated_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.q)))  # Convert each integer to a string        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.5695405101334533,
        "bleu_score": 0,
        "levenshtein": 52
    },
    {
        "middle": "class KnapsackAlg:",
        "fill": "class KnapsackAlg:",
        "original_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "generated_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "correct": true,
        "exact_match": 1,
        "chrf_score": 1.0,
        "bleu_score": 1.491668146240062e-154,
        "levenshtein": 0
    },
    {
        "middle": "import os",
        "fill": "from math import pow",
        "original_code": "import random\nimport osfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "generated_code": "import random\nfrom math import powfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.5286977482087916,
        "bleu_score": 1.2882297539194154e-231,
        "levenshtein": 12
    },
    {
        "middle": "        with open(os.path.join(path, \"p.txt\")) as f:",
        "fill": "        with open(path) as f:",
        "original_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "generated_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(path) as f:            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.33454198439097865,
        "bleu_score": 8.214546595247418e-155,
        "levenshtein": 23
    },
    {
        "middle": "        with open(os.path.join(path, \"public_key.txt\")) as f:",
        "fill": "    def gen_p_q_seq(self):",
        "original_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "generated_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n    def gen_p_q_seq(self):            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.04697735892426164,
        "bleu_score": 0,
        "levenshtein": 49
    },
    {
        "middle": "        while(len(seq) < self.key_len):",
        "fill": "        for i in range(len(seq)):",
        "original_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "generated_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        for i in range(len(seq)):            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.3231173180528957,
        "bleu_score": 0,
        "levenshtein": 26
    },
    {
        "middle": "RANDOM_INC = 1000",
        "fill": "def binstring_to_bytes(s):",
        "original_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "generated_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\ndef binstring_to_bytes(s):\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))\n        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.010416666666666748,
        "bleu_score": 0,
        "levenshtein": 25
    },
    {
        "middle": "            self.priv_key = list(map(int, f.read().split(',')))",
        "fill": "            self.priv_key = list(map(int, f.read().split(',')))",
        "original_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "generated_code": "import random\nimport os\nfrom math import gcd\n\ndef bytes2binstr(b, n=None):\n    s = ''.join(f'{x:08b}' for x in b)\n    return s if n is None else s[:n + n // 8 + (0 if n % 8 else -1)]\n\n\nRANDOM_INC = 1000\n\nclass KnapsackAlg:\n    def __init__(self) -> None:\n        self.key_len = 250\n        self.w_max = 400\n        self.w_min = 200\n        #self.q_min = 5\n        \n    def encrypt(self, input_bytes, pub_key):\n        #0 padding\n        bin_bytes = bytes2binstr(input_bytes)\n        padded_bits = self.get_padding_bits_needed(bin_bytes)\n\n        padded_bin_num = self.pad_bits(bin_bytes)\n        blocks = [padded_bin_num[x:x+self.key_len] for x in range(0, len(padded_bin_num), self.key_len)]\n        cipher_blocks = []\n        for block in blocks:\n            cipher = 0\n            for i in range(len(block)):\n                #print(block[i])\n                cipher += pub_key[i] * int(block[i])\n            cipher_blocks.append(cipher)\n        return cipher_blocks, padded_bits\n    \n    def decipher(self, cipher_blocks, priv_key, p, q, padded_bits):\n        p_inverse = pow(p, -1, q)\n        #print(cipher_blocks)\n        messages = []\n        for cipher in cipher_blocks:\n            deciphered = (cipher * p_inverse) % q\n            msg = ['0']*self.key_len\n            for i, x in enumerate(reversed(priv_key)):\n                if deciphered > 0 and x <= deciphered:\n                    deciphered = deciphered - x\n                    msg[-i-1] = '1'\n            messages.append(''.join(msg))\n        #print(''.join(messages))\n        padding_removed = ''.join(messages)[:-padded_bits]\n        #print(padding_removed)\n        deciphered_message = self.bitstring_to_bytes(''.join(padding_removed))\n        return deciphered_message\n\n    def decode_binary_string(self, s):\n        return ''.join(chr(int(s[i*8:i*8+8],2)) for i in range(len(s)//8))\n    \n    def bitstring_to_bytes(self, s):\n        return int(s, 2).to_bytes((len(s) + 7) // 8)\n\n    def pad_bits(self, bit_str):\n        if len(bit_str) % self.key_len == 0:\n            return bit_str, 0\n        else:\n            padding_bits_needed = self.get_padding_bits_needed(bit_str)\n            padded_bit_str = bit_str + '0' * padding_bits_needed\n\n            return padded_bit_str\n    def get_padding_bits_needed(self, bit_str):\n        return self.key_len - len(bit_str) % self.key_len\n    \n    def read_params(self, path=\".\"):\n        with open(os.path.join(path, \"p.txt\")) as f:\n            self.p = int(f.read())\n        with open(os.path.join(path, \"q.txt\")) as f:\n            self.q = int(f.read())\n        with open(os.path.join(path, \"private_key.txt\")) as f: \n            self.priv_key = list(map(int, f.read().split(',')))        with open(os.path.join(path, \"public_key.txt\")) as f:\n            self.pub_key = list(map(int, f.read().split(',')))\n        return self.p, self.q, self.priv_key, self.pub_key\n\n    def gen_params(self):\n        self.p, self.q, self.priv_key = self.gen_p_q_seq()\n        self.pub_key = self.gen_pub_key()\n        with open(\"p.txt\", \"w\") as f:\n            f.write(str(self.p))\n        with open(\"q.txt\", \"w\") as f:\n            f.write(str(self.q))\n        with open(\"private_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.priv_key)))  # Convert each integer to a string\n        with open(\"public_key.txt\", \"w\") as f:\n            f.write(','.join(map(str, self.pub_key)))  # Convert each integer to a string\n\n    def gen_pub_key(self):\n        pub_key = [(self.p * w) % self.q for w in self.priv_key]\n        #self.pub_key = pub_key\n        return pub_key\n\n    def gen_p_q_seq(self):\n        #get superincreasing sequence\n        priv_key = self.gen_super()\n\n        q = sum(priv_key) + random.randint(1, RANDOM_INC)\n        \n        p = random.randint(0,q)\n        while not self.co_prime(p,q):\n            p = random.randint(0,q)\n\n        #self.p = p\n        #self.q = q\n        #self.priv_key = priv_key\n        return p, q, priv_key\n\n    def gen_w(self) -> int:\n        bits = random.randint(self.w_min, self.w_max)\n        num = random.getrandbits(bits)\n        return num\n    \n    def gen_super(self) -> list:\n        seq = []\n        seq.append(self.gen_w())\n        while(len(seq) < self.key_len):\n            #inc = random.getrandbits(self.w_min)\n            inc = random.randint(1, RANDOM_INC)\n            next = sum(seq) + inc\n            #print(bin(next))\n            #print(int.bit_length(next))\n            seq.append(next)\n        return seq\n        \n    def co_prime(self, a,b): \n        return gcd(a,b) == 1 \n            \n\ndef is_superincreasing(sequence):\n    # Start by assuming the sequence is empty or has one element\n    if len(sequence) <= 1:\n        return True\n    \n    # Initialize the sum of preceding elements\n    sum_preceding = sequence[0]\n    \n    # Iterate through the sequence starting from the second element\n    for i in range(1, len(sequence)):\n        # Check if the current element is less than or equal to the sum of preceding elements\n        if sequence[i] <= sum_preceding:\n            return False  # Sequence is not superincreasing\n        # Update the sum of preceding elements\n        sum_preceding += sequence[i]\n    \n    return True  # Sequence is superincreasing\n\n#k = KnapsackAlg()\n#params = k.gen_p_q_seq()\n#print(is_superincreasing(params[2]))\n#print(int.bit_length(params[0]), int.bit_length(params[1]))\n#print(int.bit_length(sum(params)), 2**250)",
        "correct": true,
        "exact_match": 1,
        "chrf_score": 1.0,
        "bleu_score": 1.0,
        "levenshtein": 0
    },
    {
        "middle": "            closest_piece = None",
        "fill": "            closest_piece = None",
        "original_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "generated_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "correct": true,
        "exact_match": 1,
        "chrf_score": 1.0,
        "bleu_score": 1.2213386697554703e-77,
        "levenshtein": 0
    },
    {
        "middle": "            if np.isnan(row).all() or row.size == 0:",
        "fill": "            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))",
        "original_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "generated_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.19174237262472557,
        "bleu_score": 0,
        "levenshtein": 45
    },
    {
        "middle": "                else:",
        "fill": "                else:",
        "original_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "generated_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "correct": true,
        "exact_match": 1,
        "chrf_score": 0.8333333333333334,
        "bleu_score": 1.821831989445342e-231,
        "levenshtein": 0
    },
    {
        "middle": "        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)",
        "fill": "        _, thresh = cv2.threshold(thresh, 255, 255, cv2.THRESH_BINARY)",
        "original_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "generated_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        _, thresh = cv2.threshold(thresh, 255, 255, cv2.THRESH_BINARY)        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.19915756402103235,
        "bleu_score": 1.1200407237786664e-231,
        "levenshtein": 52
    },
    {
        "middle": "        board_height = self.config.board_height",
        "fill": "        new_box = center + vectors",
        "original_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "generated_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        new_box = center + vectors        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.07525345308566382,
        "bleu_score": 1.2183324802375697e-231,
        "levenshtein": 32
    },
    {
        "middle": "                vector[0] *= left_percentage",
        "fill": "                vector[0] *= left_percentage",
        "original_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "generated_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "correct": true,
        "exact_match": 1,
        "chrf_score": 1.0,
        "bleu_score": 1.2213386697554703e-77,
        "levenshtein": 0
    },
    {
        "middle": "        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)",
        "fill": "        box_held = self.shrink_sides(box_held, self.config.held_left, self.config.held_right)",
        "original_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "generated_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_sides(box_held, self.config.held_left, self.config.held_right)\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.6491637546568297,
        "bleu_score": 8.38826642100846e-155,
        "levenshtein": 24
    },
    {
        "middle": "    def detect_board_state2(self, box_board, rgb_image, debug=False):",
        "fill": "    def detect_board_state2(self, box_board, rgb_image, debug=False):",
        "original_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "generated_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "correct": true,
        "exact_match": 1,
        "chrf_score": 1.0,
        "bleu_score": 1.0,
        "levenshtein": 0
    },
    {
        "middle": "        return board_state",
        "fill": "    def draw_debug_board(self, debug_board, debug=False):",
        "original_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "generated_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():\n                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n    def draw_debug_board(self, debug_board, debug=False):\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "correct": false,
        "exact_match": 0,
        "chrf_score": 0.19808983842959008,
        "bleu_score": 0,
        "levenshtein": 40
    },
    {
        "middle": "                for piece, color in self.config.colors.items():",
        "fill": "                for piece, color in self.config.colors.items():",
        "original_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "generated_code": "import numpy as np\nimport cv2\nfrom config import TetrioConfig, TetrisConfig\nimport easyocr\n\n\n\nclass TetrisGame():\n    def __init__(self, config: TetrisConfig):\n        self.config = config\n\n    def shrink_sides(self, box, left_percentage, right_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the x-coordinates of the vectors\n        for vector in vectors:\n            if vector[0] < 0:\n                vector[0] *= left_percentage\n            else:\n                vector[0] *= right_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n\n    def shrink_vertically(self, box, top_percentage, bottom_percentage):\n        # Calculate the center of the box\n        center = np.mean(box, axis=0)\n\n        # Calculate the vectors from the center to the points\n        vectors = box - center\n\n        # Adjust the y-coordinates of the vectors\n        for vector in vectors:\n            if vector[1] < 0:\n                vector[1] *= top_percentage\n            else:\n                vector[1] *= bottom_percentage\n\n        # Calculate the new box points\n        new_box = center + vectors\n\n        return new_box.astype(int)\n    \n\n\n    def detect_board_state2(self, box_board, rgb_image, debug=False):\n        box_board_cv2 = np.array(box_board, dtype=np.float32)\n\n        # Calculate the bounding rectangle\n        x, y, w, h = cv2.boundingRect(box_board_cv2)\n\n        board = rgb_image[y:y+h, x:x+w]\n\n        board_height = self.config.board_height\n        board_width = self.config.board_width\n\n        # Improved cell size calculation\n        cell_heights = [h // board_height + (i < h % board_height) for i in range(board_height)]\n        cell_widths = [w // board_width + (i < w % board_width) for i in range(board_width)]\n\n        board_state = np.zeros((board_height, board_width), dtype=str)\n        \n        # Create a copy of the board for drawing the debug grid\n        debug_board = board.copy() if debug else None\n\n        current_y = 0\n        for i in range(board_height):\n            current_x = 0\n            for j in range(board_width):\n                cell = board[current_y:current_y+cell_heights[i], current_x:current_x+cell_widths[j]]\n                \n                # Draw the cell boundaries for debug purposes\n                if debug:\n                    cv2.rectangle(debug_board, (current_x, current_y), (current_x + cell_widths[j], current_y + cell_heights[i]), (0, 255, 0), 1)\n                \n                current_x += cell_widths[j]\n\n                if np.isnan(cell).all() or cell.size == 0:\n                    continue\n\n                # Improved color detection logic\n                avg_color = np.mean(cell.reshape(-1, 3), axis=0).astype(int)\n                min_diff = float('inf')\n                closest_piece = None\n                for piece, color in self.config.colors.items():                    diff = np.linalg.norm(avg_color - color)\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                if min_diff < self.config.color_diff_board_threshold:\n                    board_state[i, j] = closest_piece\n                    if debug:\n                        print(min_diff, closest_piece)\n                else:\n                    board_state[i, j] = '-'\n            current_y += cell_heights[i]\n\n        # Display the debug board with grid\n        if debug:\n            cv2.imshow('Debug Board with Grid', debug_board)\n            cv2.waitKey(0)  # Wait for a key press\n            cv2.destroyAllWindows()  # Close the window\n\n        return board_state\n\n    \n    def adjust_box_to_aspect_ratio(self, box, aspect_ratio):\n        x, y, w, h = cv2.boundingRect(box)\n\n        # Calculate the desired width and height\n        if w >= h * aspect_ratio:\n            if aspect_ratio == 1/2:\n                #make width divisible by 10 (round up to nearest 10) for cell size\n                w = (w + 5) // 10 * 10\n            desired_width = w\n            desired_height = w / aspect_ratio\n        else:\n            desired_height = h\n            desired_width = h * aspect_ratio\n\n        # Calculate the new x and y coordinates to center the new bounding rectangle\n        new_x = x + w/2 - desired_width/2\n        new_y = y + h/2 - desired_height/2\n\n        # Create the new box\n        new_box = np.array([\n            [round(new_x), round(new_y)],\n            [round(new_x + desired_width), round(new_y)],\n            [round(new_x + desired_width), round(new_y + desired_height)],\n            [round(new_x), round(new_y + desired_height)]\n        ], dtype=np.intp)\n\n        return new_box\n    \n    def adjust_box(self, image, box):\n        # Get the minimum and maximum x and y coordinates\n        min_x, min_y = np.min(box, axis=0)\n        max_x, max_y = np.max(box, axis=0)\n\n        # Adjust the coordinates if they go outside of the image dimensions\n        min_x = max(0, min_x)\n        min_y = max(0, min_y)\n        max_x = min(max_x, image.shape[1])\n        max_y = min(max_y, image.shape[0])\n\n        # Create a new box that is within the image dimensions\n        return np.array([[min_x, min_y], [max_x, min_y], [max_x, max_y], [min_x, max_y]], dtype=np.intp)\n\n    def detect_game_state(self, image, debug=False):\n        # Preprocess the image\n        rgb_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        gray = cv2.cvtColor(rgb_image, cv2.COLOR_RGB2GRAY)\n        _, thresh = cv2.threshold(gray, self.config.threshold, 255, cv2.THRESH_BINARY)    # Find contours of the Tetris board\n        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        if contours:\n            if self.config.lock_contour and self.config.board_contour is not None:\n                board_contour = self.config.board_contour\n            else:\n                board_contour = max(contours, key=lambda contour: cv2.boundingRect(contour)[3])\n                self.config.board_contour = board_contour\n        else:\n            print(\"No contours found\")\n            return\n        \n        # Find the rotated rectangle\n        rect = cv2.minAreaRect(board_contour)\n        box = cv2.boxPoints(rect)\n        box = np.intp(box)\n        box_board = self.shrink_sides(box, self.config.board_left, self.config.board_right)\n        box_board = self.shrink_vertically(box_board, self.config.board_vert_top, self.config.board_vert_bottom)\n\n        box_next = self.shrink_sides(box, self.config.next_left, self.config.next_right)\n        box_next = self.shrink_vertically(box_next, self.config.next_vert_top, self.config.next_vert_bottom)\n\n        box_held = self.shrink_sides(box, self.config.held_left, self.config.held_right)\n        box_held = self.shrink_vertically(box_held, self.config.held_vert_top, self.config.held_vert_bottom)\n\n        box_garbage = self.shrink_sides(box, self.config.garbage_left, self.config.garbage_right)\n\n        # Adjust the boxes\n        box_board = self.adjust_box(image, box_board)\n        box_next = self.adjust_box(image, box_next)\n        box_held = self.adjust_box(image, box_held)\n        box_garbage = self.adjust_box(image, box_garbage)\n\n        if debug:\n            cv2.drawContours(image, [box_board], 0, (0, 255, 0), 1)\n            cv2.drawContours(image, [box], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_next], 0, (233, 123, 123), 2)\n            cv2.drawContours(image, [box_held], 0, (77, 122, 154), 2)\n            cv2.drawContours(image, [box_garbage], 0, (0, 0, 231), 2)\n\n        held_piece = self.detect_held_piece(box_held, rgb_image)\n        next_pieces = self.detect_next_pieces(box_next, rgb_image)\n        board_state = self.detect_board_state2(box_board, rgb_image, debug=debug)\n        garbage_lines = self.detect_garbage(box_garbage, rgb_image)\n\n        return (board_state, held_piece, next_pieces, garbage_lines)\n\n    def detect_next_pieces(self, box_next, rgb_image):\n        # Extract the region of the image corresponding to the next pieces\n        x, y, w, h = cv2.boundingRect(box_next)\n        next_region = rgb_image[y:y+h, x:x+w]\n\n        # Divide the region into cells\n        cell_height, cell_width = h // self.config.next_pieces, w\n        next_pieces = []\n\n        # Detect the color of each cell\n        for i in range(self.config.next_pieces):\n            cell = next_region[i*cell_height:(i+1)*cell_height, :]\n            \n            # Resize the cell image to a larger size\n            resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n            \n            # Apply Gaussian blur to reduce noise\n            blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n            \n            # Convert the cell image to grayscale\n            gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n            \n            # Apply thresholding to create a binary image\n            _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n            \n            # Find contours in the binary image\n            contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n            if len(contours) > 0:\n                # Find the largest contour which is expected to be the tetromino\n                largest_contour = max(contours, key=cv2.contourArea)\n                \n                # Create a mask where the contour is\n                mask = np.zeros_like(gray_cell)\n                cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n                \n                # Calculate the average color of the ROI using the mask\n                avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n                \n                min_diff = float('inf')\n                closest_piece = None\n                \n                for piece, color in self.config.colors.items():\n                    if piece == 'G' or piece == 'GM' or piece == 'GM2':  # Ignore piece G\n                        continue\n                    diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                    if diff < min_diff:\n                        min_diff = diff\n                        closest_piece = piece\n                \n                if min_diff < self.config.color_diff_next_threshold:\n                    #print(min_diff, closest_piece)\n                    next_pieces.append(closest_piece)\n\n        return next_pieces\n\n    def detect_held_piece(self, box_held, rgb_image):\n        # Extract the region of the image corresponding to the held piece\n        x, y, w, h = cv2.boundingRect(box_held)\n\n        # Check if box_held is valid\n        if x >= 0 and y >= 0 and x + w <= rgb_image.shape[1] and y + h <= rgb_image.shape[0]:\n            held_region = rgb_image[y:y+h, x:x+w]\n        else:\n            print(\"Invalid box_held\")\n            return\n\n        cell_height, cell_width, _ = held_region.shape\n        cell = held_region\n\n        # Resize the cell image to a larger size\n        resized_cell = cv2.resize(cell, (cell_width*2, cell_height*2))\n        \n        # Apply Gaussian blur to reduce noise\n        blurred_cell = cv2.GaussianBlur(resized_cell, (5, 5), 0)\n        \n        # Convert the cell image to grayscale\n        gray_cell = cv2.cvtColor(blurred_cell, cv2.COLOR_RGB2GRAY)\n        \n        # Apply thresholding to create a binary image\n        _, thresh_cell = cv2.threshold(gray_cell, 50, 255, cv2.THRESH_BINARY)\n        \n        # Find contours in the binary image\n        contours, _ = cv2.findContours(thresh_cell, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n        \n        if len(contours) > 0:\n            # Find the largest contour which is expected to be the held piece\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create a mask where the contour is\n            mask = np.zeros_like(gray_cell)\n            cv2.drawContours(mask, [largest_contour], -1, 255, -1) # -1 to fill the contour\n            \n            # Calculate the average color of the ROI using the mask\n            avg_color = cv2.mean(resized_cell, mask=mask)[:3]  # Only take the first three channels\n            \n            min_diff = float('inf')\n            closest_piece = None\n            \n            for piece, color in self.config.colors.items():\n                if piece == 'G':  # Ignore piece G\n                    continue\n                diff = np.linalg.norm(np.array(avg_color) - np.array(color))\n                if diff < min_diff:\n                    min_diff = diff\n                    closest_piece = piece\n\n            if min_diff < self.config.color_diff_hold_threshold:\n                return closest_piece\n        return None\n\n    def detect_garbage(self, box_garbage, rgb_image):\n        # Extract the region of the image corresponding to the garbage area\n        x, y, w, h = cv2.boundingRect(box_garbage)\n        garbage_region = rgb_image[y:y+h, x:x+w]\n\n        # The height of one row in the garbage area\n        row_height = h // self.config.board_height\n\n        # Initialize the count of garbage lines\n        garbage_lines = 0\n\n        # Check each horizontal line in the garbage region for the presence of the garbage color\n        for i in range(self.config.board_height):\n            # Extract one row of pixels from the garbage region\n            row = garbage_region[i * row_height: (i + 1) * row_height, :]\n\n            if np.isnan(row).all() or row.size == 0:\n                continue\n            # Calculate the average color of this row\n            avg_color = tuple(np.average(row, axis=(0, 1)).astype(int))\n            \n\n            # Calculate the difference between the average color and the garbage color\n            garbage_color = self.config.colors[\"GM\"]  # The color defined for garbage blocks\n            diff = np.linalg.norm(np.array(avg_color) - np.array(garbage_color))\n            black = (0, 0, 0)\n            diff_black = np.linalg.norm(np.array(avg_color) - np.array(black))\n\n\n            # If the difference is below a certain threshold, increment the garbage line count\n            if diff_black > self.config.color_diff_garbage_threshold:\n                garbage_lines += 1\n\n        # Return the total count of garbage lines detected\n        return garbage_lines\n\n\n    def get_remaining_pieces(self, current_piece, next_pieces):\n        # Define the order of pieces used by TETR.IO\n        tetromino_order = [\"Z\", \"L\", \"O\", \"S\", \"I\", \"J\", \"T\"]\n\n        # Create a copy of the tetromino order\n        remaining_pieces = tetromino_order.copy()\n\n        # Remove the current piece from the remaining pieces\n        if current_piece in remaining_pieces:\n            remaining_pieces.remove(current_piece)\n\n        # Remove the next pieces from the remaining pieces\n        for piece in next_pieces:\n            if piece in remaining_pieces:\n                remaining_pieces.remove(piece)\n\n        return remaining_pieces\n",
        "correct": true,
        "exact_match": 1,
        "chrf_score": 1.0,
        "bleu_score": 1.0,
        "levenshtein": 0
    }
]